people often say you don't need to know

any math to program a computer and

that's truthy however any sufficiently

advanced technology is indistinguishable

from Magic but magic isn't real math

Explains It All developers often avoid

learning math because it looks scary but

it actually makes complicated magic like

computer graphics and neural networks

easier to understand and not just that

but it unlocks the secrets of the entire

physical Universe there's a few abstract

math concepts for programmers that you

just can't ignore and understanding them

will make you think more like a true

engineer I'm no math genius in fact I'm

the opposite which makes me uniquely

qualified to teach 10 essential math

concepts using memes and other visual

aids that almost anybody can understand

the first person who survives until the

end and cracks the code will win this

one of a kind Balenciaga fireship hoodie

let's jump right into topic number one

Boolean algebra which is used almost

every time you write code a Boolean is a

binary variable that can have two

possible values true or false now there

are three operators that you can use to

work with them and or in not or

conjunction disjunction and negation if

you want to be fancy imagine you're

trying to get a girlfriend we can use

the Boolean variables of rich and

handsome to describe you if you're both

rich and handsome you'll definitely get

a girlfriend but if you're not rich and

not handsome you'll have to pay for an

only Fan's girlfriend if you're rich or

handsome you can still get a girlfriend

but your selection is more limited we

can represent this logic and code with

things like if statements but we can

also do it visually with Venn diagrams

like you've been doing since grade

school and you can also create truth

tables like this one here which comes in

handy in zombie apocalypse type

situations but that brings us to concept

2 numeral systems like base 2 throughout

history humans have come up with all

kinds of clever ways to count things but

almost all of them use base 10 like the

10 fingers on your hands like in the

number 423 the four is in the hundreds

place which represents four times one

hundred the two is in the tens place or

two times ten then the final number is

multiplied by one but computers work off

of a base 2 numeral system in base 2

things work the exact same way but

because we only have two symbols to work

with each place is multiplied by two

like two four eight sixteen Thirty 32 64

128 and so on now that you understand

that you also understand how other bases

work like base 16 or hexadecimal which

uses the digits 0 through 9 along with a

through F and is commonly used to

represent binary values in a more

concise way because each hexadecimal

digit can translate into four bits and

you also have base64 which introduces

even more letters and symbols to encode

binary values allowing developers to

represent binary data like an image as a

string of text while computers use base

2 under the hood they still need to

represent base 10 numbers for humans and

the most common way to do that is with

floating Point numbers go ahead and

execute 0.1 plus 0.2 in your favorite

programming language the result should

be

0.30004 How could a computer make such a

silly mistake

well in science numbers can get very big

when talking about space and very small

when talking about things like atoms we

don't write these numbers out completely

and instead use scientific notation

where an exponent raises it to an

approximate value making the number

appear far more concise computers use a

similar approach with floating Point

numbers because they only have a limited

amount of space either 32 bits for

single Precision or 64 for double

Precision which is the default in

languages like Python and JavaScript

it's called a floating point because

there's no fixed number of digits before

or after the decimal point allowing

developers to make a trade-off between

range and precision some numbers like

.01 can't be represented perfectly as a

binary floating point which is the

reason we get those tiny rounding errors

now that you know how numbers work we

can start talking about logarithmic

functions which you might remember from

algebra class to understand them think

of an actual log the log starts at 16

feet then we saw it in half over and

over again until we reach a length of 2.

notice how when we try to draw a line

through it it's not perfectly straight

but rather it curves gradually in

computer science this is how many

algorithms work like binary search

what's interesting though is that if we

know how many times we cut the log we

can raise 2 to the power of that value

in this case 4 to get the original

length of the log that's called

exponentiation and logarithm is the

exact opposite imagine we don't know the

exponent we only know the original

length and want to figure out how many

times we'd have to cut the log to get a

length of 2 we could calculate that with

a base 2 log on the original length

returning a value of 4 when it's base 2

it's called a binary logarithm however

in math it's more common to use base 10

which is called the common logarithm

that'll come in handy but now let's

shift gears to set theory a set is just

an unordered collection of unique values

the best example is a relational

database where each table is a set of

unique rows these tables can be joined

together in a variety of different ways

based on set theory like to select

records that match on both tables you do

an inner join which is called an

intersection and set theory or to grab

all matching records from both tables

you do a full outer join which is a

union and set theory when doing left and

right joins these concepts are combined

like by combining an intersection with

the difference between the two sets now

one thing that's important to notice at

this point is that we're talking about

structures that have a finite number of

elements which falls under the umbrella

of discrete math as opposed to

continuous math like geometry and

calculus that deal with real numbers and

approximations and that brings us to our

next discrete topic com combinatorics

simply put this is all about counting

things especially when combining sets

into combinations or permutations like

if you have an app like Tinder you might

need to count all the possible

combinations of matches as part of a

more complex algorithm that figures out

what to show the end user where maybe

you're building a globally distributed

database and need to figure out how many

database partitions you'll need around

the world ultimately it's all about

understanding how patterns can emerge

what you're looking at here is the

formula for the Fibonacci sequence a

great exercise is to write a function

that generates it congrats bro you just

did combinatorics and unlock the secrets

of the universe engineers at Google use

the same kind of logic to render tiles

on tools like Google Maps and the gods

use this pattern all over the place in

nature combinatorics is closely related

to graph Theory a graph has two basic

parts nodes or vertices and edges that

connect them together like a person

might be a node and an edge might be a

relationship that connects them together

like you love your mom and your mom

loves you back this is an undirected

graph because the relationship goes both

ways however you might also love your

only Fan's girlfriend but this would be

a directed graph because that

relationship only goes One Way edges can

also be weighted meaning one

relationship is more important than the

other if a node can Traverse back to

itself it's called cyclic otherwise it's

known as acyclic as a programmer you'll

often need to build graphs from the

ground up but more importantly know how

to Traverse them like when using

dijkstra's algorithms you find the most

efficient way to navigate through

traffic but before you start writing

graph traversal algorithms you should

know a little bit about complexity

Theory which can tell us in theory how

much time and memory an algorithm should

use we use Big O notation to express

complexity and when talking about time

the input represents the number of steps

it will take to complete a task like if

we read a single element from an array

that would give us o of 1 or constant

time which is extremely fast and simple

if we need to Loop over an array that

would give us o of n where n is the

length of the array but if for each

iteration in that Loop we Loop over the

same array again that would give us o of

N squared which would be far less

efficient however more sophisticated

algorithms like binary search cut the

search area in half after each iteration

providing us with logarithmic time

understanding how to measure complexity

is essential for technical interviews

and is just a good thing to think about

in general but now let's move away from

discrete math and talk about statistics

which is crucial if you want to do

anything with artificial intelligence

because machine learning is kind of just

a fancy way of doing statistics like

when you type in a chat GPT it generates

a response based on the probability that

it fits the prompt provided by the user

at the very least you should understand

mean median and mode and how standard

deviation indicates how close values in

a set are correlated to the mean there's

a ton to learn beyond that but what I

found especially useful is the

difference between linear regression and

logistic regression in a linear

regression the goal is to predict a

continuous value like the amount of

money you'll lose after buying a stock

the relationship between the input and

output variable is linear and the idea

is to find a line that best fits the

data set however logistic regression is

used for an entirely different set of

problems like classification maybe an

app that predicts if an image is a hot

dog or not a hot dog in this case the

relationship is not linear but rather a

sigmoid function which might predict the

probability that a Boolean variable is

true or false and that brings us to our

final and most difficult topic linear

algebra which comes into play in things

like computer graphics and deep neural

networks to comprehend it you'll need to

understand three weird words scalar is a

single numeric value a vector is a list

of numbers like a one-dimensional array

and finally a matrix is like a grid or

two-dimensional array that contains rows

and Columns of numeric values what's

cool is that vectors can represent

points and directions in a 3D space

while matrices can represent

Transformations that happen to these

vectors when you move a player around in

a video game the lighting and shadows

and the graphics change magically but

it's not magic it's linear algebra

that's being distributed on your GPU

imagine you have a 2d Vector that's at

0.2 X 3y it represents a single point in

an image we can perform linear

Transformations here like scaling

translation rotation shear and so on

let's imagine we now want to scale the

point to a value of 4X 6y we can

represent the scaling factors in a

matrix then represent the point as a

column vector and now we can use matrix

multiplication to scale the point to its

Target location operations like this are

also essential in things like

cryptography such as RSA encryption and

are also essential in deep neural

networks which use vectors to represent

features then use matrix multiplication

to propagate values between nodes in the

network the underlying math is

surprisingly simple but requires a

massive amount of computing power to

handle the Staggering amount of data

required as you can see now math is

actually not that complicated and the

more you study it the more the computer

will reveal its magic tricks thanks for

watching and I will see you in the next

one

